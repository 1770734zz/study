+ 自我介绍
+ 做过研发之类的工作么？
+ 最近的项目，怎么做的？工作量在哪？

+ 自己实现一个vector怎么做？每次扩大size时怎么扩大？为什么这样？怎么不一次加一个空间？
  如果没有空间容纳新元素，容器必须重新分配内存空间来保存已有元素和新元素，将已有元素从旧位置移动到
  新位置，然后添加新元素，释放旧存储空间。
  linux中，将分配先有空间的2倍大小的新空间，这样可以预留一些新空间，更高效。

+ vector和list有什么区别？
  vector是连续数组，支持随机读，链表是链式结构，不能随机读，只能遍历，插入和删除比较适合。

+ 迭代器的erase有什么要注意的？
  erase删除迭代器所指向元素，返回一个指向被删元素之后元素的迭代器。vector和string是连续存储的,删除位置之后的迭代器会失效。

+ map用过么？怎么实现的？能erase么？能遍历么？
  map底层用红黑树实现。。。。
  能erase，可以用关键字、迭代器、迭代器所指范围来删除。
  能遍历，红黑树的遍历。


+ hashmap用过么？底层怎么实现？hash表的冲突怎么解决？
  哈希表。
  解决冲突：
  1. 开放定址法:
    1. 线性探测：碰撞时从当前位置的下一个位置开始寻找空位置，只要表够大，总能找到一个空位置，但会造成一次聚集
    ②平方探测：碰撞时，探测位置函数流行的选择f(i) = i^2，虽然消除了一次聚集，但是散列到同一个 位置的元素将探测相同的单元，这叫做二次聚集
    ③伪随机数列：探测位置为伪随机数列
    ④双重散列：流行选择f(i) = i * hash(x)，是开放定址法最好的方法之一，说白了就是把碰撞的元 素再用另外一个函数计算查找的位置

    注意：在探测散列表中标准的删除操作不能执行，因为相应单元可能已经冲突，元素在此基础上存放在别处，如果删除一个，那么可能剩下的find操作都会失败，因此需要懒惰删除。即想要删除某个元素，只把它所在的单元设置为‘deleted’，标示其为删除的元素，防止下一次查找时出现‘断链’情况。

  2. 链地址法：
    将散列到同一个位置的元素用一个链表链接起来，如果是新元素，则插入到链表的前端，因为这样不仅方便，而且新插入的元素最有可能不久被访问。

  3. 再散列：
    对于使用平方探测的开放定址散列法，如果表中的元素个数太多，操作时间将消耗过长，解决方法是建立另外一个大约两倍大小的表，将每个元素重新插入到新表中，表的大小取两倍后第一个素数。
               
    装填因子 = 表中元素个数/散列表大小

    如果表满到一半、插入失败或者装填因子到一定阈值，就执行再散列。


+ hashmap和map有什么区别？举个例子只能用hashmap不能用map或者只能用map不能用hashmap
   map红黑树，hashmap散列表，map可以进行遍历，而hashmap不能遍历。

+ 线程死锁怎么解决？
  1. 取消所有死锁进程
  2. 把每个死锁进程回滚到前面定义的某些检查点，并且重新启动所有进程
  3. 连续取消进程直到不再存在死锁，进程选择基于某种最小代价原则
  4. 连续抢占资源直到不再存在死锁，进程选择基于某种最小代价原则

  最小代价原则：
  1. 目前为止消耗的处理器时间最少
  2. 目前为止产生的输出最少
  3. 预计剩下的时间最长
  4. 目前为止分配的资源总量最少
  5. 优先级最低


+ 什么是线程安全？
  如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
  或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。

  存在竞争的线程不安全，不存在竞争的线程就是安全的

+ 游戏排行榜前100怎么实现？复杂度？
  1. 利用MySQL来实现，存放一张用户积分表，算法简单，查询简单，但是对于海量数据，性能差

  2. 用一个数组rank表示积分与排名的关系，rank[i]表示积分i所对应的排名，查询的话直接查询rank[i]即可，当用户积分从i更新为i+n时，则将rank[i]到rank[i+n-1]这n个元素的值加一即可。


+ 爬虫爬网上图片资源，用深度优先搜索还是广度优先搜索？为什么？
  广度优先搜索用队列实现，深度优先搜索用栈实现。
  1. 深度优先搜索：不保留全部节点，占用空间小，有回溯操作，运行速度慢。
  2. 广度优先搜索：保留全部节点，占用空间大，无回溯操作，运行速度快。

+ 看什么技术论坛？

+ linux改变swap空间命令，挂载磁盘命令？
  swapon  swapoff

+ 空闲时间做什么？

+ 喜欢玩游戏么，喜欢做游戏么？

+ 给定一个数n，返回从1到n的所有排列组合，思路即可

第一种是递归求解
[CSDN原文链接](https://blog.csdn.net/Hackbuteer1/article/details/6657435)
```C++
#include "iostream"
#include <vector>
using namespace std;
 
void permutation(vector<int> &vec,int k,int m)
{
    int i,j;
    if(k == m)
    {
        for(i=0;i<=m;i++)
            cout<<vec[i];
        cout<<endl;
    }
    else
    {
        for(j=k;j<=m;j++)
        {
            swap(vec[j],vec[k]);
            permutation(vec,k+1,m);
            swap(vec[j],vec[k]);
        }
    }
}
int main(void)
{
    vector<int> vec{1, 2, 3};
    cout << "所有全排列的结果为：" << endl;
    permutation(vec,0,2);
    return 0;
}
```
第二种是用STL里的库函数，next_permutation用来判断是否存在下一个字典序的排列，若存在，返回true
并生成这个序列，若不存在，返回false，并重排为最小的排列
```C++
#include <iostream>
#include <algorithm>
using namespace std;
 
void permutation(vector<int> &vec)
{
    sort(vec.begin(),vec.end());
    do
    {
        for(auto x : vec)
            cout << x;
        cout << endl;
    }while(next_permutation(vec.begin(),vec.end()));
 
}
int main(void)
{
    vector<int> vec{1,2,3};
    cout<<"所有全排列的结果为："<<endl;
    permutation(vec);
    return 0;
}
```
